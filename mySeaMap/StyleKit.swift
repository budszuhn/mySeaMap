//
//  StyleKit.swift
//  mySeaMap
//
//  Created by Peer Sandtner on 28.12.16.
//  Copyright Â© 2016 Peer Sandtner. See LICENSE.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class StyleKit : NSObject {

    //// Cache

    private struct Cache {
        static var imageOfTrackingOn: UIImage?
        static var trackingOnTargets: [AnyObject]?
        static var imageOfTrackingOff: UIImage?
        static var trackingOffTargets: [AnyObject]?
        static var imageOfTrackingHeading: UIImage?
        static var trackingHeadingTargets: [AnyObject]?
        static var imageOfSettings: UIImage?
        static var settingsTargets: [AnyObject]?
        static var imageOfInstruments: UIImage?
        static var instrumentsTargets: [AnyObject]?
        static var imageOfSearch: UIImage?
        static var searchTargets: [AnyObject]?
        static var imageOfCollapse: UIImage?
        static var collapseTargets: [AnyObject]?
        static var imageOfExpand: UIImage?
        static var expandTargets: [AnyObject]?
    }

    //// Drawing Methods

    public dynamic class func drawCrossHair(frame: CGRect = CGRect(x: 0, y: 0, width: 21, height: 21), crossHairStrokeColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000), crossHairStrokeWidth: CGFloat = 1) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let crossHair: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)


        //// CrossHair
        //// Vertical Line Drawing
        let verticalLinePath = UIBezierPath()
        verticalLinePath.move(to: CGPoint(x: crossHair.minX + 0.50000 * crossHair.width, y: crossHair.minY + 0.00000 * crossHair.height))
        verticalLinePath.addLine(to: CGPoint(x: crossHair.minX + 0.50000 * crossHair.width, y: crossHair.minY + 1.00000 * crossHair.height))
        crossHairStrokeColor.setStroke()
        verticalLinePath.lineWidth = crossHairStrokeWidth
        verticalLinePath.stroke()


        //// Horizontal Line Drawing
        let horizontalLinePath = UIBezierPath()
        horizontalLinePath.move(to: CGPoint(x: crossHair.minX + 0.00000 * crossHair.width, y: crossHair.minY + 0.50000 * crossHair.height))
        horizontalLinePath.addLine(to: CGPoint(x: crossHair.minX + 1.00000 * crossHair.width, y: crossHair.minY + 0.50000 * crossHair.height))
        crossHairStrokeColor.setStroke()
        horizontalLinePath.lineWidth = crossHairStrokeWidth
        horizontalLinePath.stroke()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: crossHair.minX + fastFloor(crossHair.width * 0.21429) + 0.5, y: crossHair.minY + fastFloor(crossHair.height * 0.21429) + 0.5, width: fastFloor(crossHair.width * 0.78571) - fastFloor(crossHair.width * 0.21429), height: fastFloor(crossHair.height * 0.78571) - fastFloor(crossHair.height * 0.21429)))
        crossHairStrokeColor.setStroke()
        ovalPath.lineWidth = crossHairStrokeWidth
        ovalPath.stroke()
    }

    public dynamic class func drawTrackingOn(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 22, height: 22), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 22, height: 22), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 22, y: resizedFrame.height / 22)


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 20.9, y: 1))
        bezierPath.addLine(to: CGPoint(x: 2.4, y: 9.41))
        bezierPath.addLine(to: CGPoint(x: 12.49, y: 9.41))
        bezierPath.addLine(to: CGPoint(x: 12.49, y: 19.5))
        bezierPath.addLine(to: CGPoint(x: 20.9, y: 1))
        bezierPath.close()
        UIColor.white.setFill()
        bezierPath.fill()
        UIColor.white.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()
        
        context.restoreGState()

    }

    public dynamic class func drawTrackingOff(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 22, height: 22), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 22, height: 22), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 22, y: resizedFrame.height / 22)


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 20.9, y: 1))
        bezierPath.addLine(to: CGPoint(x: 2.4, y: 9.41))
        bezierPath.addLine(to: CGPoint(x: 12.49, y: 9.41))
        bezierPath.addLine(to: CGPoint(x: 12.49, y: 19.5))
        bezierPath.addLine(to: CGPoint(x: 20.9, y: 1))
        bezierPath.close()
        UIColor.white.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()
        
        context.restoreGState()

    }

    public dynamic class func drawTrackingHeading(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 22, height: 22), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 22, height: 22), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 22, y: resizedFrame.height / 22)


        //// Group
        //// Bezier Drawing
        context.saveGState()
        context.translateBy(x: 5, y: 6.42)

        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 6.12, y: 0.58))
        bezierPath.addLine(to: CGPoint(x: 0, y: 15.23))
        bezierPath.addLine(to: CGPoint(x: 6.12, y: 9.74))
        bezierPath.addLine(to: CGPoint(x: 12.24, y: 15.23))
        bezierPath.addLine(to: CGPoint(x: 6.12, y: 0.58))
        bezierPath.close()
        UIColor.white.setFill()
        bezierPath.fill()

        context.restoreGState()


        //// Schniepel Drawing
        context.saveGState()
        context.translateBy(x: 11.05, y: 0)

        let schniepelPath = UIBezierPath()
        schniepelPath.move(to: CGPoint(x: 0, y: 5.5))
        schniepelPath.addLine(to: CGPoint(x: 0, y: 0.5))
        UIColor.white.setStroke()
        schniepelPath.lineWidth = 1
        schniepelPath.stroke()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawSettings(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 22, height: 22), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 22, height: 22), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 22, y: resizedFrame.height / 22)


        //// Gear Drawing
        let gearPath = UIBezierPath()
        gearPath.move(to: CGPoint(x: 12.14, y: 0.59))
        gearPath.addCurve(to: CGPoint(x: 12.93, y: 3.67), controlPoint1: CGPoint(x: 12.42, y: 1.69), controlPoint2: CGPoint(x: 12.71, y: 2.8))
        gearPath.addCurve(to: CGPoint(x: 14.85, y: 4.46), controlPoint1: CGPoint(x: 13.61, y: 3.84), controlPoint2: CGPoint(x: 14.25, y: 4.11))
        gearPath.addCurve(to: CGPoint(x: 17.58, y: 2.84), controlPoint1: CGPoint(x: 15.62, y: 4), controlPoint2: CGPoint(x: 16.61, y: 3.42))
        gearPath.addCurve(to: CGPoint(x: 19.18, y: 4.44), controlPoint1: CGPoint(x: 18.17, y: 3.32), controlPoint2: CGPoint(x: 18.7, y: 3.85))
        gearPath.addCurve(to: CGPoint(x: 17.56, y: 7.18), controlPoint1: CGPoint(x: 18.6, y: 5.42), controlPoint2: CGPoint(x: 18.02, y: 6.4))
        gearPath.addCurve(to: CGPoint(x: 18.36, y: 9.09), controlPoint1: CGPoint(x: 17.91, y: 7.77), controlPoint2: CGPoint(x: 18.18, y: 8.41))
        gearPath.addCurve(to: CGPoint(x: 21.43, y: 9.88), controlPoint1: CGPoint(x: 19.23, y: 9.32), controlPoint2: CGPoint(x: 20.34, y: 9.6))
        gearPath.addCurve(to: CGPoint(x: 21.49, y: 11.01), controlPoint1: CGPoint(x: 21.47, y: 10.25), controlPoint2: CGPoint(x: 21.49, y: 10.63))
        gearPath.addCurve(to: CGPoint(x: 21.43, y: 12.14), controlPoint1: CGPoint(x: 21.49, y: 11.39), controlPoint2: CGPoint(x: 21.47, y: 11.77))
        gearPath.addCurve(to: CGPoint(x: 18.36, y: 12.93), controlPoint1: CGPoint(x: 20.34, y: 12.42), controlPoint2: CGPoint(x: 19.23, y: 12.71))
        gearPath.addCurve(to: CGPoint(x: 17.56, y: 14.85), controlPoint1: CGPoint(x: 18.18, y: 13.61), controlPoint2: CGPoint(x: 17.91, y: 14.25))
        gearPath.addCurve(to: CGPoint(x: 19.18, y: 17.58), controlPoint1: CGPoint(x: 18.02, y: 15.62), controlPoint2: CGPoint(x: 18.6, y: 16.61))
        gearPath.addCurve(to: CGPoint(x: 17.58, y: 19.18), controlPoint1: CGPoint(x: 18.7, y: 18.17), controlPoint2: CGPoint(x: 18.17, y: 18.7))
        gearPath.addCurve(to: CGPoint(x: 14.85, y: 17.56), controlPoint1: CGPoint(x: 16.61, y: 18.6), controlPoint2: CGPoint(x: 15.62, y: 18.02))
        gearPath.addCurve(to: CGPoint(x: 12.93, y: 18.36), controlPoint1: CGPoint(x: 14.25, y: 17.91), controlPoint2: CGPoint(x: 13.61, y: 18.18))
        gearPath.addCurve(to: CGPoint(x: 12.14, y: 21.43), controlPoint1: CGPoint(x: 12.71, y: 19.23), controlPoint2: CGPoint(x: 12.42, y: 20.34))
        gearPath.addCurve(to: CGPoint(x: 11.01, y: 21.49), controlPoint1: CGPoint(x: 11.77, y: 21.47), controlPoint2: CGPoint(x: 11.39, y: 21.49))
        gearPath.addCurve(to: CGPoint(x: 9.88, y: 21.43), controlPoint1: CGPoint(x: 10.63, y: 21.49), controlPoint2: CGPoint(x: 10.25, y: 21.47))
        gearPath.addCurve(to: CGPoint(x: 9.09, y: 18.36), controlPoint1: CGPoint(x: 9.6, y: 20.34), controlPoint2: CGPoint(x: 9.32, y: 19.23))
        gearPath.addCurve(to: CGPoint(x: 7.18, y: 17.56), controlPoint1: CGPoint(x: 8.41, y: 18.18), controlPoint2: CGPoint(x: 7.77, y: 17.91))
        gearPath.addCurve(to: CGPoint(x: 4.44, y: 19.18), controlPoint1: CGPoint(x: 6.4, y: 18.02), controlPoint2: CGPoint(x: 5.42, y: 18.6))
        gearPath.addCurve(to: CGPoint(x: 2.84, y: 17.58), controlPoint1: CGPoint(x: 3.85, y: 18.7), controlPoint2: CGPoint(x: 3.32, y: 18.17))
        gearPath.addCurve(to: CGPoint(x: 4.46, y: 14.85), controlPoint1: CGPoint(x: 3.42, y: 16.61), controlPoint2: CGPoint(x: 4, y: 15.62))
        gearPath.addCurve(to: CGPoint(x: 3.67, y: 12.93), controlPoint1: CGPoint(x: 4.11, y: 14.25), controlPoint2: CGPoint(x: 3.84, y: 13.61))
        gearPath.addCurve(to: CGPoint(x: 0.59, y: 12.14), controlPoint1: CGPoint(x: 2.8, y: 12.71), controlPoint2: CGPoint(x: 1.69, y: 12.42))
        gearPath.addCurve(to: CGPoint(x: 0.53, y: 11.01), controlPoint1: CGPoint(x: 0.55, y: 11.77), controlPoint2: CGPoint(x: 0.53, y: 11.39))
        gearPath.addCurve(to: CGPoint(x: 0.59, y: 9.88), controlPoint1: CGPoint(x: 0.53, y: 10.63), controlPoint2: CGPoint(x: 0.55, y: 10.25))
        gearPath.addCurve(to: CGPoint(x: 3.67, y: 9.09), controlPoint1: CGPoint(x: 1.69, y: 9.6), controlPoint2: CGPoint(x: 2.8, y: 9.32))
        gearPath.addCurve(to: CGPoint(x: 4.46, y: 7.18), controlPoint1: CGPoint(x: 3.84, y: 8.41), controlPoint2: CGPoint(x: 4.11, y: 7.77))
        gearPath.addCurve(to: CGPoint(x: 2.84, y: 4.44), controlPoint1: CGPoint(x: 4, y: 6.4), controlPoint2: CGPoint(x: 3.42, y: 5.42))
        gearPath.addCurve(to: CGPoint(x: 4.44, y: 2.84), controlPoint1: CGPoint(x: 3.32, y: 3.85), controlPoint2: CGPoint(x: 3.85, y: 3.32))
        gearPath.addCurve(to: CGPoint(x: 7.18, y: 4.46), controlPoint1: CGPoint(x: 5.42, y: 3.42), controlPoint2: CGPoint(x: 6.4, y: 4))
        gearPath.addLine(to: CGPoint(x: 7.26, y: 4.41))
        gearPath.addCurve(to: CGPoint(x: 9.09, y: 3.67), controlPoint1: CGPoint(x: 7.83, y: 4.09), controlPoint2: CGPoint(x: 8.44, y: 3.84))
        gearPath.addCurve(to: CGPoint(x: 9.85, y: 0.71), controlPoint1: CGPoint(x: 9.31, y: 2.83), controlPoint2: CGPoint(x: 9.58, y: 1.76))
        gearPath.addLine(to: CGPoint(x: 9.88, y: 0.6))
        gearPath.addCurve(to: CGPoint(x: 11.01, y: 0.53), controlPoint1: CGPoint(x: 10.25, y: 0.55), controlPoint2: CGPoint(x: 10.63, y: 0.53))
        gearPath.addCurve(to: CGPoint(x: 12.14, y: 0.59), controlPoint1: CGPoint(x: 11.39, y: 0.53), controlPoint2: CGPoint(x: 11.77, y: 0.55))
        gearPath.close()
        gearPath.move(to: CGPoint(x: 10.83, y: 7.63))
        gearPath.addCurve(to: CGPoint(x: 9.81, y: 7.78), controlPoint1: CGPoint(x: 10.48, y: 7.63), controlPoint2: CGPoint(x: 10.14, y: 7.68))
        gearPath.addCurve(to: CGPoint(x: 7.28, y: 11.19), controlPoint1: CGPoint(x: 8.35, y: 8.22), controlPoint2: CGPoint(x: 7.28, y: 9.58))
        gearPath.addCurve(to: CGPoint(x: 10.83, y: 14.75), controlPoint1: CGPoint(x: 7.28, y: 13.15), controlPoint2: CGPoint(x: 8.87, y: 14.75))
        gearPath.addCurve(to: CGPoint(x: 14.39, y: 11.19), controlPoint1: CGPoint(x: 12.8, y: 14.75), controlPoint2: CGPoint(x: 14.39, y: 13.15))
        gearPath.addCurve(to: CGPoint(x: 10.83, y: 7.63), controlPoint1: CGPoint(x: 14.39, y: 9.22), controlPoint2: CGPoint(x: 12.8, y: 7.63))
        gearPath.close()
        UIColor.black.setStroke()
        gearPath.lineWidth = 1
        gearPath.stroke()
        
        context.restoreGState()

    }

    public dynamic class func drawInstruments(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 22, height: 22), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 22, height: 22), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 22, y: resizedFrame.height / 22)


        //// Group
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 0.5, y: 0.5, width: 21, height: 21))
        UIColor.black.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()


        //// Center Oval Drawing
        context.saveGState()
        context.translateBy(x: 11, y: 11)
        context.scaleBy(x: 0.8, y: 0.8)

        let centerOvalPath = UIBezierPath(ovalIn: CGRect(x: -1.95, y: -1.88, width: 3.92, height: 3.92))
        UIColor.black.setStroke()
        centerOvalPath.lineWidth = 1
        centerOvalPath.stroke()

        context.restoreGState()


        //// Bezier Drawing
        context.saveGState()
        context.translateBy(x: 11, y: 11.87)

        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: -0, y: -9.66))
        bezierPath.addLine(to: CGPoint(x: -0, y: -6.96))
        UIColor.black.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()

        context.restoreGState()


        //// Bezier 2 Drawing
        context.saveGState()
        context.translateBy(x: 11.87, y: 11)

        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: -9.66, y: -0))
        bezier2Path.addLine(to: CGPoint(x: -6.96, y: 0))
        UIColor.black.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()

        context.restoreGState()


        //// Bezier 3 Drawing
        context.saveGState()
        context.translateBy(x: 10.13, y: 11)

        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 9.66, y: -0))
        bezier3Path.addLine(to: CGPoint(x: 6.96, y: -0))
        UIColor.black.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()

        context.restoreGState()


        //// Bezier 4 Drawing
        context.saveGState()
        context.translateBy(x: 11.33, y: 11.8)

        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: -3.7, y: -8.93))
        bezier4Path.addLine(to: CGPoint(x: -2.66, y: -6.43))
        UIColor.black.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()

        context.restoreGState()


        //// Bezier 5 Drawing
        context.saveGState()
        context.translateBy(x: 11.61, y: 11.61)

        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: -6.83, y: -6.83))
        bezier5Path.addLine(to: CGPoint(x: -4.92, y: -4.92))
        UIColor.black.setStroke()
        bezier5Path.lineWidth = 1
        bezier5Path.stroke()

        context.restoreGState()


        //// Bezier 6 Drawing
        context.saveGState()
        context.translateBy(x: 10.67, y: 11.8)

        let bezier6Path = UIBezierPath()
        bezier6Path.move(to: CGPoint(x: 3.7, y: -8.93))
        bezier6Path.addLine(to: CGPoint(x: 2.66, y: -6.43))
        UIColor.black.setStroke()
        bezier6Path.lineWidth = 1
        bezier6Path.stroke()

        context.restoreGState()


        //// Bezier 7 Drawing
        context.saveGState()
        context.translateBy(x: 10.39, y: 11.61)

        let bezier7Path = UIBezierPath()
        bezier7Path.move(to: CGPoint(x: 6.83, y: -6.83))
        bezier7Path.addLine(to: CGPoint(x: 4.92, y: -4.92))
        UIColor.black.setStroke()
        bezier7Path.lineWidth = 1
        bezier7Path.stroke()

        context.restoreGState()


        //// Bezier 8 Drawing
        context.saveGState()
        context.translateBy(x: 11.8, y: 10.67)

        let bezier8Path = UIBezierPath()
        bezier8Path.move(to: CGPoint(x: -8.93, y: 3.7))
        bezier8Path.addLine(to: CGPoint(x: -6.43, y: 2.66))
        UIColor.black.setStroke()
        bezier8Path.lineWidth = 1
        bezier8Path.stroke()

        context.restoreGState()


        //// Bezier 9 Drawing
        context.saveGState()
        context.translateBy(x: 10.2, y: 10.67)

        let bezier9Path = UIBezierPath()
        bezier9Path.move(to: CGPoint(x: 8.93, y: 3.7))
        bezier9Path.addLine(to: CGPoint(x: 6.43, y: 2.66))
        UIColor.black.setStroke()
        bezier9Path.lineWidth = 1
        bezier9Path.stroke()

        context.restoreGState()


        //// Bezier 10 Drawing
        context.saveGState()
        context.translateBy(x: 11.8, y: 11.33)

        let bezier10Path = UIBezierPath()
        bezier10Path.move(to: CGPoint(x: -8.93, y: -3.7))
        bezier10Path.addLine(to: CGPoint(x: -6.43, y: -2.66))
        UIColor.black.setStroke()
        bezier10Path.lineWidth = 1
        bezier10Path.stroke()

        context.restoreGState()


        //// Bezier 11 Drawing
        context.saveGState()
        context.translateBy(x: 10.2, y: 11.33)

        let bezier11Path = UIBezierPath()
        bezier11Path.move(to: CGPoint(x: 8.93, y: -3.7))
        bezier11Path.addLine(to: CGPoint(x: 6.43, y: -2.66))
        UIColor.black.setStroke()
        bezier11Path.lineWidth = 1
        bezier11Path.stroke()

        context.restoreGState()


        //// Bezier 12 Drawing
        context.saveGState()
        context.translateBy(x: 10.88, y: 11.12)

        let bezier12Path = UIBezierPath()
        bezier12Path.move(to: CGPoint(x: 6.34, y: -6.34))
        bezier12Path.addLine(to: CGPoint(x: 1, y: -1))
        UIColor.black.setStroke()
        bezier12Path.lineWidth = 1
        bezier12Path.stroke()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawSearch(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 22, height: 22), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 22, height: 22), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 22, y: resizedFrame.height / 22)


        //// Group
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 0.5, y: 0.5, width: 16, height: 16))
        UIColor.black.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 14.02, y: 14.02))
        bezierPath.addLine(to: CGPoint(x: 21, y: 21))
        UIColor.black.setStroke()
        bezierPath.lineWidth = 2
        bezierPath.stroke()
        
        context.restoreGState()

    }

    public dynamic class func drawCanvas1(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 66, height: 64), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 66, height: 64), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 66, y: resizedFrame.height / 64)


        //// Symbol Drawing
        let symbolRect = CGRect(x: 1, y: 1, width: 22, height: 22)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        StyleKit.drawTrackingOn(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch)
        context.restoreGState()


        //// Symbol 2 Drawing
        let symbol2Rect = CGRect(x: 28, y: 1, width: 22, height: 22)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)

        StyleKit.drawTrackingOff(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch)
        context.restoreGState()


        //// Symbol 3 Drawing
        let symbol3Rect = CGRect(x: 9, y: 30, width: 22, height: 22)
        context.saveGState()
        context.clip(to: symbol3Rect)
        context.translateBy(x: symbol3Rect.minX, y: symbol3Rect.minY)

        StyleKit.drawTrackingHeading(frame: CGRect(origin: .zero, size: symbol3Rect.size), resizing: .stretch)
        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawCollapse(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 22, height: 22), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 22, height: 22), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 22, y: resizedFrame.height / 22)


        //// Group
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 0.5, y: 21.5))
        bezierPath.addLine(to: CGPoint(x: 9.5, y: 12.5))
        bezierPath.addLine(to: CGPoint(x: 8.5, y: 13.5))
        UIColor.black.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 9.5, y: 19.5))
        bezier2Path.addLine(to: CGPoint(x: 9.5, y: 12.5))
        bezier2Path.addLine(to: CGPoint(x: 2.5, y: 12.5))
        UIColor.black.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()


        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 21.5, y: 0.5))
        bezier3Path.addLine(to: CGPoint(x: 12.5, y: 9.5))
        bezier3Path.addLine(to: CGPoint(x: 13.5, y: 8.5))
        UIColor.black.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 12.5, y: 2.5))
        bezier4Path.addLine(to: CGPoint(x: 12.5, y: 9.5))
        bezier4Path.addLine(to: CGPoint(x: 19.5, y: 9.5))
        UIColor.black.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()
        
        context.restoreGState()

    }

    public dynamic class func drawExpand(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 22, height: 22), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 22, height: 22), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 22, y: resizedFrame.height / 22)


        //// Group
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 0.5, y: 21.5))
        bezierPath.addLine(to: CGPoint(x: 9.5, y: 12.5))
        bezierPath.addLine(to: CGPoint(x: 8.5, y: 13.5))
        UIColor.black.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 0.5, y: 14.5))
        bezier2Path.addLine(to: CGPoint(x: 0.5, y: 21.5))
        bezier2Path.addLine(to: CGPoint(x: 7.5, y: 21.5))
        UIColor.black.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()


        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 21.5, y: 0.5))
        bezier3Path.addLine(to: CGPoint(x: 12.5, y: 9.5))
        bezier3Path.addLine(to: CGPoint(x: 13.5, y: 8.5))
        UIColor.black.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 21.5, y: 7.5))
        bezier4Path.addLine(to: CGPoint(x: 21.5, y: 0.5))
        bezier4Path.addLine(to: CGPoint(x: 14.5, y: 0.5))
        UIColor.black.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()
        
        context.restoreGState()

    }

    //// Generated Images

    public dynamic class func imageOfCrossHair(imageSize: CGSize = CGSize(width: 21, height: 21), crossHairStrokeColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000), crossHairStrokeWidth: CGFloat = 1) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            StyleKit.drawCrossHair(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), crossHairStrokeColor: crossHairStrokeColor, crossHairStrokeWidth: crossHairStrokeWidth)

        let imageOfCrossHair = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets.zero, resizingMode: .tile)
        UIGraphicsEndImageContext()

        return imageOfCrossHair
    }

    public dynamic class var imageOfTrackingOn: UIImage {
        if Cache.imageOfTrackingOn != nil {
            return Cache.imageOfTrackingOn!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 22, height: 22), false, 0)
            StyleKit.drawTrackingOn()

        Cache.imageOfTrackingOn = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfTrackingOn!
    }

    public dynamic class var imageOfTrackingOff: UIImage {
        if Cache.imageOfTrackingOff != nil {
            return Cache.imageOfTrackingOff!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 22, height: 22), false, 0)
            StyleKit.drawTrackingOff()

        Cache.imageOfTrackingOff = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfTrackingOff!
    }

    public dynamic class var imageOfTrackingHeading: UIImage {
        if Cache.imageOfTrackingHeading != nil {
            return Cache.imageOfTrackingHeading!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 22, height: 22), false, 0)
            StyleKit.drawTrackingHeading()

        Cache.imageOfTrackingHeading = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfTrackingHeading!
    }

    public dynamic class var imageOfSettings: UIImage {
        if Cache.imageOfSettings != nil {
            return Cache.imageOfSettings!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 22, height: 22), false, 0)
            StyleKit.drawSettings()

        Cache.imageOfSettings = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfSettings!
    }

    public dynamic class var imageOfInstruments: UIImage {
        if Cache.imageOfInstruments != nil {
            return Cache.imageOfInstruments!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 22, height: 22), false, 0)
            StyleKit.drawInstruments()

        Cache.imageOfInstruments = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfInstruments!
    }

    public dynamic class var imageOfSearch: UIImage {
        if Cache.imageOfSearch != nil {
            return Cache.imageOfSearch!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 22, height: 22), false, 0)
            StyleKit.drawSearch()

        Cache.imageOfSearch = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfSearch!
    }

    public dynamic class var imageOfCollapse: UIImage {
        if Cache.imageOfCollapse != nil {
            return Cache.imageOfCollapse!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 22, height: 22), false, 0)
            StyleKit.drawCollapse()

        Cache.imageOfCollapse = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfCollapse!
    }

    public dynamic class var imageOfExpand: UIImage {
        if Cache.imageOfExpand != nil {
            return Cache.imageOfExpand!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 22, height: 22), false, 0)
            StyleKit.drawExpand()

        Cache.imageOfExpand = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfExpand!
    }

    //// Customization Infrastructure

    @IBOutlet dynamic var trackingOnTargets: [AnyObject]! {
        get { return Cache.trackingOnTargets }
        set {
            Cache.trackingOnTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKit.imageOfTrackingOn)
            }
        }
    }

    @IBOutlet dynamic var trackingOffTargets: [AnyObject]! {
        get { return Cache.trackingOffTargets }
        set {
            Cache.trackingOffTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKit.imageOfTrackingOff)
            }
        }
    }

    @IBOutlet dynamic var trackingHeadingTargets: [AnyObject]! {
        get { return Cache.trackingHeadingTargets }
        set {
            Cache.trackingHeadingTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKit.imageOfTrackingHeading)
            }
        }
    }

    @IBOutlet dynamic var settingsTargets: [AnyObject]! {
        get { return Cache.settingsTargets }
        set {
            Cache.settingsTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKit.imageOfSettings)
            }
        }
    }

    @IBOutlet dynamic var instrumentsTargets: [AnyObject]! {
        get { return Cache.instrumentsTargets }
        set {
            Cache.instrumentsTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKit.imageOfInstruments)
            }
        }
    }

    @IBOutlet dynamic var searchTargets: [AnyObject]! {
        get { return Cache.searchTargets }
        set {
            Cache.searchTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKit.imageOfSearch)
            }
        }
    }

    @IBOutlet dynamic var collapseTargets: [AnyObject]! {
        get { return Cache.collapseTargets }
        set {
            Cache.collapseTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKit.imageOfCollapse)
            }
        }
    }

    @IBOutlet dynamic var expandTargets: [AnyObject]! {
        get { return Cache.expandTargets }
        set {
            Cache.expandTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: StyleKit.imageOfExpand)
            }
        }
    }




    @objc public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
